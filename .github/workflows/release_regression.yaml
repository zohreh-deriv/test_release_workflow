name: Release Regression Workflow

on:
  create:
    branches:
      - release-v**

jobs:
  generate_regression:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/heads/release-v')
    steps:
      - name: Checkout code
        # should use hash commit due to security issues
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          fetch-depth: 0
          ssh-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Get branch name and version
        id: branch_info
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          APP_VERSION=${BRANCH_NAME#release-v}
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT

      - name: Update pubspec version
        run: |
          sed -i "s/^version: .*/version: ${{ steps.branch_info.outputs.app_version }}/" pubspec.yaml

      - name: Commit and push the version update and create a Pull Request to master.
        uses: peter-evans/create-pull-request@76c6f5c20e2111bfee3cd30fae52a25e410f5efc
        with:
          # personal access token of the mobile deriv apps
          token: ${{ secrets.MOBILE_APPS_PAT }}
          title: "chore: sync branches, merge release version ${{ steps.branch_info.outputs.app_version }} into master"
          branch: ${{ steps.branch_info.outputs.branch_name }}
          commit-message: "chore: update app version to ${{ steps.branch_info.outputs.app_version }}"
          base: master

      - name: Generate tag name
        id: tag_info
        run: |
          DATE=$(date +'%d-%m-%Y')
          BASE_TAG="firebase-${DATE}-${{ steps.branch_info.outputs.app_version }}"

          # Check for existing tags with same app version
          EXISTING_TAGS=$(git tag -l "firebase-*-${{ steps.branch_info.outputs.app_version }}*")
          if [ -z "$EXISTING_TAGS" ]; then
            TAG_NAME=$BASE_TAG
          else
            COUNT=$(echo "$EXISTING_TAGS" | wc -l)
            TAG_NAME="${BASE_TAG}+${COUNT}"
          fi
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Create Release Tag
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.MOBILE_APPS_PAT }} # personal access token mobile team account
        with:
          tag_name: ${{ steps.tag_info.outputs.tag_name }}
          release_name: Release ${{ steps.tag_info.outputs.tag_name }}
          body: |
            Automated release for version ${{ steps.branch_info.outputs.app_version }}

            Changes since last release:
            ${{ github.event.head_commit.message }}
          draft: false
          prerelease: true

      - name: Wait for Bitrise Build
        id: wait_build
        env:
          BITRISE_APP_ID: ${{ secrets.BITRISE_APP_ID }}
          BITRISE_PAT: ${{ secrets.BITRISE_PAT }}
        run: |
          # Wait for build to appear (it might take a few seconds after tag creation)
          sleep 30

          # Initialize build_slug as empty
          BUILD_SLUG=""

          # First, find the build with matching tag
          while [ -z "$BUILD_SLUG" ]; do
            echo "Searching for build with tag: ${{ steps.tag_info.outputs.tag_name }}"
            
            # Get recent builds
            BUILDS=$(curl -s https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds?limit=10 \
              --header "Authorization: $BITRISE_PAT")
            
            # Check if response contains data array
            if ! echo "$BUILDS" | jq -e '.data' > /dev/null; then
              echo "Error: API response does not contain 'data' array"
              echo "Full API Response:"
              echo "$BUILDS"
              echo "Waiting 30 seconds before retry..."
              sleep 30
              continue
            fi
            
            # Extract build slug and number for the matching tag
            BUILD_INFO=$(echo "$BUILDS" | jq -r --arg TAG "${{ steps.tag_info.outputs.tag_name }}" \
              '.data[] | select(.tag == $TAG) | {slug: .slug, build_number: .build_number}' | jq -s '.[0]')
            
            if [ -n "$BUILD_INFO" ] && [ "$BUILD_INFO" != "null" ]; then
              BUILD_SLUG=$(echo "$BUILD_INFO" | jq -r '.slug')
              BUILD_NUMBER=$(echo "$BUILD_INFO" | jq -r '.build_number')
              echo "Found build! Slug: $BUILD_SLUG, Number: $BUILD_NUMBER"
              echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
            else
              echo "No build found yet. Waiting 30 seconds..."
              sleep 30
            fi
          done

          # Now that we have the build slug, only check this specific build's status
          while true; do
            echo "Checking status of build: $BUILD_NUMBER"
            
            # Get status of specific build
            BUILD_STATUS=$(curl -s "https://api.bitrise.io/v0.1/apps/$BITRISE_APP_ID/builds/$BUILD_SLUG" \
              --header "Authorization: $BITRISE_PAT" | jq -r '.data.status_text')
            
            echo "Current build status: $BUILD_STATUS"
            
            if [ "$BUILD_STATUS" = "success" ]; then
              echo "Build succeeded!"
              exit 0
            elif [ "$BUILD_STATUS" = "failed" ] || [ "$BUILD_STATUS" = "aborted" ]; then
              echo "Build failed with status: $BUILD_STATUS"
              exit 1
            fi
            
            echo "Build still in progress. Waiting 30 seconds..."
            sleep 30
          done

      - name: Send Success Slack Notification
        if: steps.wait_build.outcome == 'success'
        uses: ./.github/actions/regression_notif
        with:
          SLACK_WEBHOOK_URL: ${{ secrets.RELEASE_SLACK_WEBHOOK_URL }}
          NEW_VERSION: ${{ steps.branch_info.outputs.app_version }}
          BUILD_NUMBER: ${{ steps.wait_build.outputs.build_number }}
